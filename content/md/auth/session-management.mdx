---
title: 'Session Management'
description: 'Learn how to implement and manage user sessions in your Next.js application'
---

# Session Management

## Overview

Session management is crucial for maintaining user authentication state and security. This guide covers implementation using NextAuth.js session handling.

## Implementation

### 1. Session Configuration

```typescript
// lib/auth.ts
import { NextAuthOptions } from "next-auth";

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
    updateAge: 24 * 60 * 60, // 24 hours
  },
  callbacks: {
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
        // Add custom session data
        session.user.role = token.role as string;
      }
      return session;
    },
    async jwt({ token, user }) {
      if (user) {
        // Add custom JWT data
        token.role = user.role;
      }
      return token;
    },
  },
};
```

### 2. Session Provider

```typescript
// app/providers.tsx
import { SessionProvider } from "next-auth/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      {children}
    </SessionProvider>
  );
}
```

### 3. Session Hooks

```typescript
// hooks/use-session.ts
import { useSession } from "next-auth/react";

export function useAuth() {
  const { data: session, status } = useSession();
  
  return {
    user: session?.user,
    isAuthenticated: status === "authenticated",
    isLoading: status === "loading",
  };
}
```

## Session Protection

### 1. Middleware Protection

```typescript
// middleware.ts
import { withAuth } from "next-auth/middleware";

export default withAuth({
  callbacks: {
    authorized: ({ token }) => !!token,
  },
});

export const config = {
  matcher: [
    "/dashboard/:path*",
    "/profile/:path*",
    "/settings/:path*",
  ],
};
```

### 2. Route Protection

```typescript
// components/auth/protected-route.tsx
import { useAuth } from "@/hooks/use-session";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, isLoading } = useAuth();
  const router = useRouter();
  
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push("/login");
    }
  }, [isLoading, isAuthenticated, router]);
  
  if (isLoading) {
    return <div>Loading...</div>;
  }
  
  return isAuthenticated ? <>{children}</> : null;
}
```

## Session Data

### 1. Custom Session Type

```typescript
// types/next-auth.d.ts
import "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      email: string;
      name: string;
      role: string;
      // Add custom fields
    };
  }
  
  interface User {
    role: string;
    // Add custom fields
  }
}
```

### 2. Session Storage

```typescript
// lib/session.ts
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

export async function getSession() {
  return await getServerSession(authOptions);
}

export async function getCurrentUser() {
  const session = await getSession();
  return session?.user;
}
```

## Session Actions

### 1. Sign Out

```typescript
// components/auth/sign-out-button.tsx
import { signOut } from "next-auth/react";

export function SignOutButton() {
  const handleSignOut = async () => {
    await signOut({
      callbackUrl: "/login",
    });
  };
  
  return (
    <button onClick={handleSignOut}>
      Sign Out
    </button>
  );
}
```

### 2. Session Update

```typescript
// lib/session.ts
export async function updateSession(data: Partial<Session>) {
  const session = await getSession();
  
  if (!session) {
    throw new Error("No active session");
  }
  
  // Update session data
  Object.assign(session, data);
  
  // Trigger session update
  await fetch("/api/auth/session", {
    method: "POST",
    body: JSON.stringify(data),
  });
}
```

## Security Features

### 1. Session Expiration

```typescript
// lib/auth.ts
export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
    updateAge: 24 * 60 * 60, // 24 hours
  },
  // Additional configuration
};
```

### 2. Session Validation

```typescript
// lib/session.ts
export async function validateSession(session: Session) {
  if (!session?.user?.id) {
    throw new Error("Invalid session");
  }
  
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
  });
  
  if (!user) {
    throw new Error("User not found");
  }
  
  return user;
}
```

## Best Practices

### 1. Session Security

- Use secure session storage
- Implement session expiration
- Validate session data
- Handle session errors

### 2. Performance

- Minimize session data
- Use efficient storage
- Implement caching
- Optimize updates

### 3. User Experience

- Handle loading states
- Provide clear feedback
- Implement smooth transitions
- Handle edge cases

## Error Handling

### 1. Session Errors

```typescript
// lib/session.ts
export async function handleSessionError(error: unknown) {
  if (error instanceof Error) {
    if (error.message === "Invalid session") {
      // Handle invalid session
      await signOut();
    } else if (error.message === "User not found") {
      // Handle missing user
      await signOut();
    }
  }
  
  // Log error
  console.error("Session error:", error);
}
```

### 2. Error Boundaries

```typescript
// components/error-boundary.tsx
import { Component, ErrorInfo, ReactNode } from "react";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };
  
  public static getDerivedStateFromError(): State {
    return { hasError: true };
  }
  
  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Session error:", error, errorInfo);
  }
  
  public render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Something went wrong</h1>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

## Next Steps

1. Implement session persistence
2. Add session analytics
3. Enhance security features
4. Improve user experience

For more detailed information about specific features, refer to the relevant sections in this documentation. 