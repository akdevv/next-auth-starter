---
title: 'Using Credentials Auth'
description: 'Learn how to implement and use credentials-based authentication in your Next.js application'
---

# Using Credentials Auth

## Overview

Credentials authentication allows users to sign in with email and password. This guide covers implementation, security best practices, and customization options.

## Implementation

### 1. Configure NextAuth.js

```typescript
// lib/auth.ts
import CredentialsProvider from "next-auth/providers/credentials";
import { compare } from "bcryptjs";
import { prisma } from "@/lib/prisma";

export const authOptions = {
  providers: [
    CredentialsProvider({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Invalid credentials");
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email }
        });

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isValid = await compare(credentials.password, user.password);

        if (!isValid) {
          throw new Error("Invalid credentials");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
      }
    })
  ],
  // Additional configuration
};
```

### 2. Create Login Form

```typescript
// components/auth/login-form.tsx
import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";

export function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("Invalid credentials");
        return;
      }

      router.push("/dashboard");
    } catch (error) {
      setError("An error occurred");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="error">{error}</div>}
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      <button type="submit">Sign In</button>
    </form>
  );
}
```

## Security Features

### 1. Password Hashing

```typescript
// lib/auth.ts
import { hash } from "bcryptjs";

export async function hashPassword(password: string) {
  return hash(password, 12);
}
```

### 2. Rate Limiting

```typescript
// middleware.ts
import { rateLimit } from "@/lib/rate-limit";

export default rateLimit({
  interval: 15 * 60 * 1000, // 15 minutes
  uniqueTokenPerInterval: 500,
});
```

### 3. Session Management

```typescript
// lib/auth.ts
export const authOptions = {
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  // Additional configuration
};
```

## Customization

### 1. Custom Error Messages

```typescript
async authorize(credentials) {
  try {
    // Authentication logic
  } catch (error) {
    if (error instanceof PrismaClientKnownRequestError) {
      throw new Error("Database error occurred");
    }
    throw new Error("Authentication failed");
  }
}
```

### 2. Additional User Data

```typescript
async authorize(credentials) {
  const user = await prisma.user.findUnique({
    where: { email: credentials.email },
    include: {
      profile: true,
      settings: true,
    },
  });
  // Return additional user data
}
```

## Best Practices

### 1. Password Requirements

```typescript
function validatePassword(password: string) {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChar = /[!@#$%^&*]/.test(password);

  return (
    password.length >= minLength &&
    hasUpperCase &&
    hasLowerCase &&
    hasNumbers &&
    hasSpecialChar
  );
}
```

### 2. Input Validation

```typescript
function validateEmail(email: string) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
```

## Error Handling

### 1. Form Validation

```typescript
function validateForm(email: string, password: string) {
  const errors: Record<string, string> = {};

  if (!email) {
    errors.email = "Email is required";
  } else if (!validateEmail(email)) {
    errors.email = "Invalid email format";
  }

  if (!password) {
    errors.password = "Password is required";
  } else if (!validatePassword(password)) {
    errors.password = "Password does not meet requirements";
  }

  return errors;
}
```

### 2. Error Messages

```typescript
const errorMessages = {
  "Invalid credentials": "Email or password is incorrect",
  "User not found": "No account found with this email",
  "Invalid email": "Please enter a valid email address",
  "Password required": "Please enter your password",
};
```

## Testing

### 1. Unit Tests

```typescript
describe("Login Form", () => {
  it("should validate email format", () => {
    expect(validateEmail("test@example.com")).toBe(true);
    expect(validateEmail("invalid-email")).toBe(false);
  });

  it("should validate password requirements", () => {
    expect(validatePassword("StrongP@ss123")).toBe(true);
    expect(validatePassword("weak")).toBe(false);
  });
});
```

### 2. Integration Tests

```typescript
describe("Authentication Flow", () => {
  it("should handle successful login", async () => {
    // Test implementation
  });

  it("should handle failed login", async () => {
    // Test implementation
  });
});
```

## Next Steps

1. Implement password reset
2. Add email verification
3. Set up 2FA
4. Enhance security features

For more detailed information about specific features, refer to the relevant sections in this documentation. 